# 工作十年—再看设计模式

:::tip 物极必反、月盈则亏！

任何事情都不能走极端，否则就会造成不良后果。

:::right


:::
## 什么是设计模式？
设计模式（design pattern）是对软件设计中普遍存在（反复出现）的各种问题，所提出的解决方案。

这个术语是由《设计模式：可复用面向对象软件的基础》（Design Patterns: Elements of Reusable Object-Oriented Software）这本书中提出，
这本书的作者是埃里希·伽玛（Erich Gamma）、Richard Helm（Richard Helm）、Ralph Johnson（Ralph Johnson）和John Vlissides（John Vlissides），后以“四人帮”（Gang of Four，GoF）。
有时，GoF也会用于代指《设计模式》这本书。此书中共收录了23种设计模式，即我们常见的GoF23(23种设计模式)。

谈到埃里希·伽玛（Erich Gamma）他还有个鼎鼎有名的作品——JUnit：一个Java程序的单元测试框架。相信做Java开发的小伙伴们肯定不会陌生。

## 如何学习设计模式？

  我们大多数人都会感觉学习设计模式很繁杂，内容很多不容易理解和记住。其实任何事物的诞生都不是横空出世的，可以多了解一些背景、问题、解决方案，然后将这套解决方案进行总结和抽象，让其具有更强的普适性。
  这样就产生了设计模式。

    模式名：每一个模式都有自己的名字，模式的名字使得我们可以讨论我们的设计。
    
    问题：在面向对象的系统设计过程中反复出现的特定场合，它导致我们采用某个模式。
    
    解决方案：上述问题的解决方案，其内容给出了设计的各个组成部分，它们之间的关系、职责划分和协作方式。
    
  总结和分析这套解决方案的影响：
        
    影响：采用该模式对软件系统其他部分的影响，比如对系统的扩充性、可移植性的影响。影响也包括负面的影响。这部分应描述使用本模式后的结果、副作用、与权衡(trade-off)。
      
  有了解决方案之后，就可以总结和抽象一下，是否具有适用性：
      
    适用性：模式适用于哪些情况、模式的背景等等。
  
  然后就可以将这套解决方案进行规范化：
    
    结构：类图与交互图阐述此模式。
    
    参与者：模式用到的类与对象，与它们在设计下扮演的角色。
    
    关系：描述在此模式下，类与对象间的交互。
      
    实现：这部分应描述实现该模式、该模式的部分方案、实现该模式的可能技术、或者建议实现模式的方法。
    
    示例：简略描绘出如何以编程语言来使用模式。
    
    已知应用：业界已知的实现示例。
    
  对此模式了解后，可以再发散一下，这种模式与其他模式有没有相关性？这就是常说的：举一反三！  
    
    相关模式：这部分包括其他相关模式，以及与其他类似模式的不同。
    

## 有哪些设计模式？
《设计模式》一书原把设计模式分为创建型模式、结构型模式、行为型模式。

分为这三种模式是很容易理解的，在OOP(面向对象编程)中，首先要有对象即创建模式，然后对象与对象之间要有关系即结构模式，最后对象要执行自己的方法即行为模式。

常见的设计模式包括：


相信这张图大家都不陌生，这些设计模式的名字也很熟悉，我在这里就不多说了。如果有不熟悉的随便百度一下就会有大量的文章介绍，或是再读一下上文提到的书《设计模式》。

## 真的只有这些设计模式吗？

思考一：

  如果初始化、实例化对象的成本比较高，比如做一些网络连接或大量数据的初始化，且需要经常实例化。那这时候我们应该怎么办？
  
  似乎前文的设计模式中没有给出解决办法，这其实也是一种创建型的设计模式——对象池模式(object pool pattern),一个对象池包含一组已经初始化过且可以使用的对象，而可以在有需求时创建和销毁对象。
  池的用户可以从池子中取得对象，对其进行操作处理，并在不需要时归还给池子而非直接销毁它。这其实是一种特殊的工厂对象。我们常用的数据库连接池、线程池等都是这个面模式的应用。
  
思考二：
  
  如果我们使用工厂模式创建对象，然后创建的对象会执行某个方法。但是如果调用工厂模式传入的参数是个非法参数。这时候创建不出来对象，后面的方法再执行肯定会报错了。那我们该怎么办？
  
  也许你会说工厂创建对象的时候做参数校验，或者在执行方法前判断对象是否存在，如果不存在则不再执行方法。当然这是一个方法，这种方法会增加一些代码的复杂性(非本业务的代码)。
  还有一个方法就是创建一个默认的空对象（null object）。这个空对象中的方法什么也不执行，这样就避免了null引发的问题。 这种模式被称为：空对象模式 （null object Pattern）。
  
思考三：
  
  我们使用的规则引擎是不是一种设计模式呢？通过使用布尔逻辑将业务规则链接在一起，可以重新组合业务规则。这其实也是一种设计模式：规范模式。
  规范是以可重用形式对逻辑进行封装，因此进行彻底的单元测试非常简单。
                                                                     
通过以上的思考，我们可以用上文的方法论来重新定义模式，而不是完完全全地按照GoF23来定义是否使用了设计模式。
   

## 设计模式真的可靠吗？

物极必反、月盈则亏！在项目开发不适当的时机使用设计模式，或者在不适当的场合使用设计模式，都会给项目开发带来很多不必要的复杂性，从而增加大量的沟通成本，甚至会严重影响开发效率。

以前听说过一个笑话：

    一个程序员发邮件给Erich Gamma，说在他们最近的一个项目中，他尽力使用了23种GoF设计模式中的21种，还有两种怎么也找不到适用的场合。他感到很苦恼，希望能够得到 Erich的帮助。

大量的实践证明，不当使用（不适当的时机、不适当的场合）设计模式会给项目开发带来很大的麻烦。

于是，在《设计模式》这本书的激发下，Andrew Koenig在1995年造了反模式(anti-pattern)这个词，三年后的1998年出版了《反模式——危机中软件、架构和项目的重构》（AntiPatterns——Refactoring Software, Architectures, and Projects in Crisis）
这本书对于滥用设计模式的趋势来说可谓是一剂很及时的解毒良药。

反面模式指的是在实践中经常出现但又低效或是有待优化的设计模式，是用来解决问题的带有共同性的不良方法。这种反模式的思想，不只是在软件开发过程中经常出现，
也在日常工作中经常出现。比如我们在工作的时候经常会遇到，时间紧张，将这个优化放在二期迭代，很多情况下二期约等于遥遥无期！
再或者，我们发现了一个bug，为了解决这个bug而上了一个补丁来为这个bug兜底，这样可能带来了另外一个隐藏的bug，同时也影响了最初代码的纯净度。这就是我们常说的：为了解决麻烦而制造麻烦！

在软件开发过程中的反模式包括：

    1、输入问题：无法确定和实现对异常输入的处理；
    
    2、代码膨胀：功能越来越复杂，代码越来越多，以至于最后难以维护；
    
    3、并发风险：输出结果受到事件执行顺序和时机的影响，在多线程环境和分布式系统中可能发生；
    
    4、循环依赖：在对象或软件模块中，直接或间接引入循环依赖，，包括类、jar包、模块等；
    
    5、对象粪池：复用那些不满足复用条件的对象，比如状态共享等；
    
    6、硬编码：将对系统环境的假设写入实现中，没有进行抽象或动态实现；
    
    7、魔法值：在算法里直接使用数字，而不解释含义；
    
    8、自我复制：通过不断复制已有代码的模式或代码段进行编码，而没有抽取；
    
    9、软代码：在配置文件里保存业务逻辑而不是在代码中；
    
    ……

如果对更多的反模式感兴趣，可以进一步参阅：《反模式——危机中软件、架构和项目的重构》。

# 结语

如果说《设计模式》是为了活的更好，那《反模式》则是为了避免死亡；
如果说《设计模式》是为了提高效率，那《反模式》则是为了避免事故。

我们往往会对好的事物心生向往，但我们更应该对恶的事务心生敬畏。就像我们向往蓝天白云，但我们也要敬狂风暴雨。
而往往经历了狂风暴雨才可以历练真正的强者。






