(window.webpackJsonp=window.webpackJsonp||[]).push([[72],{523:function(t,a,v){"use strict";v.r(a);var _=v(11),e=Object(_.a)({},(function(){var t=this,a=t.$createElement,v=t._self._c||a;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h1",{attrs:{id:"正则表达式"}},[t._v("正则表达式")]),t._v(" "),v("h2",{attrs:{id:"正则文法"}},[t._v("正则文法")]),t._v(" "),v("p",[t._v("要了解正则表达式的原理，需要先了解一些计算机语言文法的基础知识。")]),t._v(" "),v("p",[t._v("一个文法可以用一个四元来定义，G = {Vt，Vn，S，P}")]),t._v(" "),v("p",[t._v("其中Vt是一个非空有限的符号集合，它的每个元素成为终结符号。Vn也是一个非空有限的符号集合，它的每个元素称为非终结符号，并且Vt∩Vn=Φ。S∈Vn，称为文法G的开始符号。P是一个非空有限集合，它的元素称为产生式。所谓产生式，其形式为α→β，α称为产生式的左部，β称为产生式的右部，符号“→”表示“定义为”，并且α、β∈(Vt∪Vn)*，α≠ε，即α、β是由终结符和非终结符组成的符号串。开始符S必须至少在某一产生式的左部出现一次。")]),t._v(" "),v("p",[t._v("文法可推导的语言标记为L(G)。")]),t._v(" "),v("p",[t._v("著名语言学家Chomsky(乔姆斯基)根据对产生式所施加的限制的不同，把文法分成四种类型，即0型、1型、2型和3型。")]),t._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",[v("code",[t._v("0型文法要求至少含有一个非终结符，基本没有什么限制，一个非常重要的理论结果是：0型文法的能力相当于图灵机\n1型文法也叫上下文有关文法，对应于线性有界自动机，要求每个产生式α→β，都有|β|>=|α|，|β|指长度；\n2型文法也叫上下文无关文法，对应于下推自动机，要求在1型文法的基础上，再满足：每一个α→β都有α是非终结符;\n3型文法也叫正则文法，它对应于有限状态自动机。它是在2型文法的基础上满足：A→α|αB（右线性）或A→α|Bα（左线性)。\n")])])]),v("p",[t._v("正则表达式就是最后一种正则文法的一种表达形式，以整个字母表作为终结符集合Vt。")]),t._v(" "),v("p",[t._v("假设有一个文法的产生式是{S->Sa; S->b;}，那么对应的正则表达式为ba*。")]),t._v(" "),v("p",[t._v("因此正则表达式、正则文法、有限状态自动机这个三个概念虽然指不同的东西，但是具备内在的等价性。")]),t._v(" "),v("h2",{attrs:{id:"有限状态自动机"}},[t._v("有限状态自动机")]),t._v(" "),v("p",[t._v("正则文法对应于有限状态自动机，又分DFA 自动机（Deterministic Final Automata 确定型有穷自动机）和 NFA 自动机（Non deterministic Finite Automaton 不确定型有穷自动机）")]),t._v(" "),v("h3",{attrs:{id:"nfa"}},[t._v("NFA")]),t._v(" "),v("p",[t._v("一个字母可以标记离开状态的多条边，并且ℇ 也可以标记一条边；这说明NFA的匹配过程面临很多的岔路，需要做出选择，一旦某条岔路失败，就需要回朔。")]),t._v(" "),v("h3",{attrs:{id:"dfa"}},[t._v("DFA")]),t._v(" "),v("p",[t._v("对于每个状态以及字母表中的每个字母，只能有一条以该字母为标记的，离开该状态的边；这说明DFA的匹配过程是确定的，每个字母是需要匹配一次。")]),t._v(" "),v("p",[t._v("由于NFA和DFA的能力是一样的，每个NFA必然可以转化成一个等价的DFA。")]),t._v(" "),v("h3",{attrs:{id:"nfa与dfa的差异"}},[t._v("NFA与DFA的差异")]),t._v(" "),v("p",[t._v("很容易理解，构造DFA的代价远大于NFA，假设NFA的状态数为K，那么等价DFA的状态数目理论上可达2的k次方，不过实际上几乎不会出现这么极端的情况，可以肯定的是构造DFA会消耗更多的时间和内存。")]),t._v(" "),v("p",[t._v("但是DFA一旦构造好了之后，执行效率就非常理想了，如果一个串的长度是n，那么匹配算法的执行复杂度是O(n);而NFA在匹配过程中，存在大量的分支和回朔，假设NFA的状态数为s，因为每输入一个字符可能达到的状态数做多为s，那么匹配算法的复杂度及时输入串的长度乘以状态数O(ns)。")]),t._v(" "),v("p",[t._v('除了效率上的差别外，从更高的视点看，形成了两种风格的引擎，进而对正则表达式的匹配的其他方面能力造成差异。NFA被称之为"表达式主导"引擎，而DFA被称之为“文本主导”引擎。')]),t._v(" "),v("h3",{attrs:{id:"nfa是怎么进行匹配的？"}},[t._v("NFA是怎么进行匹配的？")]),t._v(" "),v("p",[t._v("我们以下面的字符和表达式来举例说明。")]),t._v(" "),v("div",{staticClass:"language-text extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[t._v('\ntext="Today is a nice day."\nregex="day"\n\n')])])]),v("p",[t._v("要记住一个很重要的点，即：NFA 是以正则表达式为基准去匹配的。也就是说，NFA 自动机会读取正则表达式的一个一个字符，然后拿去和目标字符串匹配，匹配成功就换正则表达式的下一个字符，否则继续和目标字符串的下一个字符比较。或许你们听不太懂，没事，接下来我们以上面的例子一步步解析。")]),t._v(" "),v("ol",[v("li",[v("p",[t._v("首先，拿到正则表达式的第一个匹配符：d。于是那去和字符串的字符进行比较，字符串的第一个字符是 T，不匹配，换下一个。第二个是 o，也不匹配，再换下一个。第三个是 d，匹配了，那么就读取正则表达式的第二个字符：a。")])]),t._v(" "),v("li",[v("p",[t._v("读取到正则表达式的第二个匹配符：a。那着继续和字符串的第四个字符 a 比较，又匹配了。那么接着读取正则表达式的第三个字符：y。")])]),t._v(" "),v("li",[v("p",[t._v("读取到正则表达式的第三个匹配符：y。那着继续和字符串的第五个字符 y 比较，又匹配了。尝试读取正则表达式的下一个字符，发现没有了，那么匹配结束。")])])]),t._v(" "),v("h3",{attrs:{id:"nfa自动机是如何回溯的？"}},[t._v("NFA自动机是如何回溯的？")]),t._v(" "),v("p",[t._v("了解了 NFA 是如何进行字符串匹配的，接下来我们就可以讲讲这篇文章的重点了：回溯。为了更好地解释回溯，我们同样以下面的例子来讲解。")]),t._v(" "),v("div",{staticClass:"language-text extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[t._v('text="abbc"\nregex="ab{1,3}c"\n')])])]),v("p",[t._v("上面的这个例子的目的比较简单，匹配以 a 开头，以 c 结尾，中间有 1-3 个 b 字符的字符串。NFA 对其解析的过程是这样子的：")]),t._v(" "),v("ol",[v("li",[t._v("首先，读取正则表达式第一个匹配符 a 和 字符串第一个字符 a 比较，匹配了。于是读取正则表达式第二个字符。")]),t._v(" "),v("li",[t._v("读取正则表达式第二个匹配符 b{1,3} 和字符串的第二个字符 b 比较，匹配了。但因为 b{1,3} 表示 1-3 个 b 字符串，以及 NFA 自动机的贪婪特性（也就是说要尽可能多地匹配），所以此时并不会再去读取下一个正则表达式的匹配符，而是依旧使用 b{1,3} 和字符串的第三个字符 b 比较，发现还是匹配。于是继续使用 b{1,3} 和字符串的第四个字符 c 比较，发现不匹配了。此时就会发生回溯。")]),t._v(" "),v("li",[t._v("发生回溯是怎么操作呢？发生回溯后，我们已经读取的字符串第四个字符 c 将被吐出去，指针回到第三个字符串的位置。之后，程序读取正则表达式的下一个操作符 c，读取当前指针的下一个字符 c 进行对比，发现匹配。于是读取下一个操作符，但这里已经结束了。")])]),t._v(" "),v("h3",{attrs:{id:"正则表达式的三种模式"}},[t._v("正则表达式的三种模式")]),t._v(" "),v("h4",{attrs:{id:"贪婪模式"}},[t._v("贪婪模式")]),t._v(" "),v("p",[t._v("在关于数量的匹配中，有 + ? * {min,max} 四种两次，如果只是单独使用，那么它们就是贪婪模式。")]),t._v(" "),v("h4",{attrs:{id:"懒惰模式"}},[t._v("懒惰模式")]),t._v(" "),v("p",[t._v("如果在他们之后加多一个 ? 符号，那么原先的贪婪模式就会变成懒惰模式，即尽可能少地匹配。")]),t._v(" "),v("div",{staticClass:"language-text extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[t._v('text="abbc"\nregex="ab{1,3}?c"\n')])])]),v("h4",{attrs:{id:"独占模式"}},[t._v("独占模式")]),t._v(" "),v("p",[t._v("如果在他们之后加多一个 + 符号，那么原先的贪婪模式就会变成独占模式，即尽可能多地匹配，但是不回溯。")]),t._v(" "),v("div",{staticClass:"language-text extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[t._v('text="abbc"\nregex="ab{1,3}+c"\n')])])])])}),[],!1,null,null,null);a.default=e.exports}}]);