(window.webpackJsonp=window.webpackJsonp||[]).push([[19],{429:function(t,e,v){t.exports=v.p+"assets/img/junit_img_1.d8d67766.png"},430:function(t,e,v){t.exports=v.p+"assets/img/junit_img_2.cd9d2276.png"},523:function(t,e,v){"use strict";v.r(e);var s=v(11),a=Object(s.a)({},(function(){var t=this,e=t.$createElement,s=t._self._c||e;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"单元测试规范"}},[t._v("单元测试规范")]),t._v(" "),s("h2",{attrs:{id:"为什么要写单测"}},[t._v("为什么要写单测")]),t._v(" "),s("p",[t._v("保证代码运行符合预期，将代码中的问题提早暴露出来，减少代码bug，提高代码质量。")]),t._v(" "),s("h2",{attrs:{id:"什么是单测"}},[t._v("什么是单测")]),t._v(" "),s("p",[t._v("单元测试(unit test)是指程序员对代码中的最小运行单元进行正确性检验的测试。")]),t._v(" "),s("h2",{attrs:{id:"怎么写单元测试"}},[t._v("怎么写单元测试")]),t._v(" "),s("p",[t._v("针对每个方法都要有单元测试")]),t._v(" "),s("blockquote",[s("p",[t._v("包括private方法")])]),t._v(" "),s("p",[t._v("针对每行代码都要有单元测试")]),t._v(" "),s("blockquote",[s("p",[t._v("包括if else 里的逻辑，包括catch里的逻辑")])]),t._v(" "),s("p",[t._v("针对每个业务场景写")]),t._v(" "),s("blockquote",[s("p",[t._v("包括异常合法的场景、不合法的场景,成功的场景、失败的场景")])]),t._v(" "),s("h2",{attrs:{id:"单元测试的步骤"}},[t._v("单元测试的步骤")]),t._v(" "),s("p",[t._v("Setup，初始化，准备数据等")]),t._v(" "),s("blockquote",[s("p",[t._v("初始化数据")])]),t._v(" "),s("p",[t._v("Execute，调用要测试的方法、函数")]),t._v(" "),s("blockquote",[s("p",[t._v("组装并执行测试方法")])]),t._v(" "),s("p",[t._v("Verify，验证结果是否符合预期")]),t._v(" "),s("p",[t._v("​\t将结果进行验证，这里一定要Verify，不要System.out.println()结果。Verify是一个验证过程，这个会影响CI的执行。")]),t._v(" "),s("p",[t._v("Teardown，重置状态")]),t._v(" "),s("blockquote",[s("p",[t._v("单测的数据不能产生其他影响，以免干扰到其他测试，所以测试结束后一定要重置状态。")]),t._v(" "),s("p",[t._v("一般都是将数据做隔离，以免减少数据的干扰。")])]),t._v(" "),s("h2",{attrs:{id:"单元测试的规范"}},[t._v("单元测试的规范")]),t._v(" "),s("ol",[s("li",[s("p",[t._v("测试类与实际类在相同包下，只是测试类是在测试包下")])]),t._v(" "),s("li",[s("p",[t._v("测试类名称为实际类名称+Test")])])]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[t._v("如：UserDaoTest\n")])])]),s("ol",{attrs:{start:"3"}},[s("li",[t._v("测试类方法为test+实际类方法")])]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[t._v("如：testLogin_Success,testLogin_Failed……\n")])])]),s("h2",{attrs:{id:"单元测试的技术"}},[t._v("单元测试的技术")]),t._v(" "),s("h3",{attrs:{id:"idea自动生成"}},[t._v("IDEA自动生成")]),t._v(" "),s("ol",[s("li",[s("p",[t._v("安装junitgenerator-v2插件，然后重启IDEA")]),t._v(" "),s("p",[s("img",{attrs:{src:v(429),alt:"img.png"}})])]),t._v(" "),s("li",[s("p",[t._v("设置junit4模板")]),t._v(" "),s("p",[t._v("基本不用调整，可以根据自己的规范，添加一些类注释，修改一下样式。")])]),t._v(" "),s("li",[s("p",[t._v("设置文件生成路径")]),t._v(" "),s("p",[s("img",{attrs:{src:v(430),alt:"img.png"}})]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[t._v(" ${SOURCEPATH}/../../test/java/${PACKAGE}/${FILENAME}\n")])])])])]),t._v(" "),s("h3",{attrs:{id:"mock技术"}},[t._v("Mock技术")]),t._v(" "),s("p",[t._v('Mock是一种模拟行为，而不是真实的做相关操作。\n对那些不容易构建的对象用一个虚拟对象来代替测试的方法就叫mock测试。以此来提高单测的"单一"特性。')]),t._v(" "),s("p",[t._v("Mock一般用于：")]),t._v(" "),s("blockquote",[s("p",[t._v("复杂的业务系统")]),t._v(" "),s("p",[t._v("外部服务调用")])]),t._v(" "),s("p",[t._v("Mock的优点：")]),t._v(" "),s("blockquote",[s("p",[t._v("团队可以并行工作")]),t._v(" "),s("p",[t._v("为无法访问的资源编写测试")]),t._v(" "),s("p",[t._v("系统进行隔离")])]),t._v(" "),s("h4",{attrs:{id:"mockito"}},[t._v("Mockito")]),t._v(" "),s("p",[t._v("Mockito 是一个基于MIT协议的开源java测试框架。 Mockito区别于其他模拟框架的地方主要是允许开发者在没有建立“预期”时验证被测系统的行为。对mock对象的一个批评是测试代码与被测系统高度耦合，由于Mockito试图通过移除“期望规范”来去除expect-run-verify模式（期望--运行--验证模式），因此使耦合度降低到最低。")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[t._v("<dependency>\n  <groupId>org.mockito</groupId>\n  <artifactId>mockito-all</artifactId>\n  <scope>test</scope>\n</dependency>\n")])])]),s("p",[t._v("需要注意的语句：")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[t._v("Mockito.when(A).thenReturn(B);\n")])])]),s("p",[t._v("需要注意的注解：")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[t._v("@InjectMocks\n")])])]),s("p",[t._v("说明：该注解跟@Autowired类似，注入一个服务。")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[t._v("@MockBean\n")])])]),s("p",[t._v("说明：注入一个服务，该服务会是“假对象”，并不会真正执行。")]),t._v(" "),s("h3",{attrs:{id:"数据库h2"}},[t._v("数据库H2")]),t._v(" "),s("p",[t._v("H2数据库是一个开源的关系型数据库。H2是一个采用java语言编写的嵌入式数据库引擎，只是一个类库（即只有一个 jar 文件），可以直接嵌入到应用项目中，不受平台的限制。")]),t._v(" "),s("p",[t._v("之所以需要H2数据库，主要是为了与其他数据库无任何干扰，从而保证测试的可靠性。")]),t._v(" "),s("p",[t._v("引入：")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[t._v("<dependency>\n    <groupId>com.h2database</groupId>\n    <artifactId>h2</artifactId>\n    <scope>runtime</scope>\n</dependency>\n")])])]),s("p",[t._v("配置：")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[t._v("spring.datasource.platform=h2  #表明使用的数据库平台是h2\nspring.datasource.url=jdbc:h2:./data/test;AUTO_SERVER=TRUE\nspring.datasource.username=sa\nspring.datasource.password=123456\nspring.datasource.driverClassName=org.h2.Driver\n")])])]),s("h3",{attrs:{id:"内嵌redis"}},[t._v("内嵌Redis")]),t._v(" "),s("p",[t._v("很多应用中会使用到Redis。而单测的时候如果把数据写入Redis或者读取Redis的数据，可能会造成一些脏数据，从而影响单测的结果。\n所以我们需要使用内嵌Redis。")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[t._v("  <dependency>\n      <groupId>com.github.kstyrc</groupId>\n      <artifactId>embedded-redis</artifactId>\n      <version>0.6</version>\n  </dependency>\n")])])]),s("p",[t._v("一般我们在写单元测试的时候，会在一个测试类中写很多的测试方法。那么我们一般会选择在@Before方法中启动RedisServer，在@After方法中进行close。\n启动与关闭：")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[t._v("redisServer = new RedisServer(6379);\nredisServer.start();\n// do something\nredisServer.stop();\n")])])]),s("h3",{attrs:{id:"单元测试的问题"}},[t._v("单元测试的问题")]),t._v(" "),s("h4",{attrs:{id:"_1-加载慢的问题"}},[t._v("1.加载慢的问题")]),t._v(" "),s("p",[t._v("原因分析：")]),t._v(" "),s("p",[t._v("首先每一次单测都需要重新加载数据，跑完一次程序就结束了，所以每次测试方法时都要重新加载数据。")]),t._v(" "),s("p",[t._v("实现方式：")]),t._v(" "),s("h4",{attrs:{id:"_2-分库分表的问题"}},[t._v("2.分库分表的问题")])])}),[],!1,null,null,null);e.default=a.exports}}]);